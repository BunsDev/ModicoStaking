"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const providers_1 = require("@ethersproject/providers");
const address_1 = require("@ethersproject/address");
const contracts_1 = require("@ethersproject/contracts");
const bignumber_1 = require("@ethersproject/bignumber");
const wallet_1 = require("@ethersproject/wallet");
const solidity_1 = require("@ethersproject/solidity");
const bytes_1 = require("@ethersproject/bytes");
const abi_1 = require("@ethersproject/abi");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const EIP173Proxy_json_1 = __importDefault(require("../artifacts/EIP173Proxy.json"));
const Diamond_json_1 = __importDefault(require("../artifacts/Diamond.json"));
const DiamondCutFacet_json_1 = __importDefault(require("../artifacts/DiamondCutFacet.json"));
const DiamondLoupeFacet_json_1 = __importDefault(require("../artifacts/DiamondLoupeFacet.json"));
const OwnershipFacet_json_1 = __importDefault(require("../artifacts/OwnershipFacet.json"));
const Diamantaire_json_1 = __importDefault(require("../artifacts/Diamantaire.json"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
Diamond_json_1.default.abi = utils_1.mergeABIs(false, Diamond_json_1.default.abi, DiamondCutFacet_json_1.default.abi, DiamondLoupeFacet_json_1.default.abi, OwnershipFacet_json_1.default.abi);
function fixProvider(providerGiven) {
    // alow it to be used by ethers without any change
    if (providerGiven.sendAsync === undefined) {
        providerGiven.sendAsync = (req, callback) => {
            providerGiven
                .send(req.method, req.params)
                .then((result) => callback(null, { result, id: req.id, jsonrpc: req.jsonrpc }))
                .catch((error) => callback(error, null));
        };
    }
    return providerGiven;
}
function findAll(toFind, array) {
    for (const f of toFind) {
        if (array.indexOf(f) === -1) {
            return false;
        }
    }
    return true;
}
function linkRawLibrary(bytecode, libraryName, libraryAddress) {
    const address = libraryAddress.replace("0x", "");
    let encodedLibraryName;
    if (libraryName.startsWith("$") && libraryName.endsWith("$")) {
        encodedLibraryName = libraryName.slice(1, libraryName.length - 1);
    }
    else {
        encodedLibraryName = solidity_1.keccak256(["string"], [libraryName]).slice(2, 36);
    }
    const pattern = new RegExp(`_+\\$${encodedLibraryName}\\$_+`, "g");
    if (!pattern.exec(bytecode)) {
        throw new Error(`Can't link '${libraryName}' (${encodedLibraryName}) in \n----\n ${bytecode}\n----\n`);
    }
    return bytecode.replace(pattern, address);
}
function linkRawLibraries(bytecode, libraries) {
    for (const libName of Object.keys(libraries)) {
        const libAddress = libraries[libName];
        bytecode = linkRawLibrary(bytecode, libName, libAddress);
    }
    return bytecode;
}
function linkLibraries(artifact, libraries) {
    let bytecode = artifact.bytecode;
    if (libraries) {
        if (artifact.linkReferences) {
            for (const [fileName, fileReferences] of Object.entries(artifact.linkReferences)) {
                for (const [libName, fixups] of Object.entries(fileReferences)) {
                    const addr = libraries[libName];
                    if (addr === undefined) {
                        continue;
                    }
                    for (const fixup of fixups) {
                        bytecode =
                            bytecode.substr(0, 2 + fixup.start * 2) +
                                addr.substr(2) +
                                bytecode.substr(2 + (fixup.start + fixup.length) * 2);
                    }
                }
            }
        }
        else {
            bytecode = linkRawLibraries(bytecode, libraries);
        }
    }
    // TODO return libraries object with path name <filepath.sol>:<name> for names
    return bytecode;
}
let solcInput;
let solcInputHash;
let solcOutput;
let provider;
const availableAccounts = {};
function addHelpers(env, partialExtension, // TODO
getArtifact, onPendingTx, getGasPrice, log, print) {
    async function init() {
        if (!provider) {
            provider = new providers_1.Web3Provider(fixProvider(env.ethereum));
            try {
                const accounts = await provider.send("eth_accounts", []);
                for (const account of accounts) {
                    availableAccounts[account.toLowerCase()] = true;
                }
            }
            catch (e) { }
            // TODO wait for buidler to have the info in artifact
            try {
                solcOutput = JSON.parse(fs_1.default
                    .readFileSync(path_1.default.join(env.config.paths.cache, "solc-output.json"))
                    .toString());
            }
            catch (e) { }
            // Necessary for etherscan it seems. using metadata seems insuficient to reconstruct the necessary info for etherscan. Here is a diff of a success vs failure case: https://gist.github.com/wighawag/dfc123ffb7838e5aeb88f58abff505f7
            try {
                solcInput = fs_1.default
                    .readFileSync(path_1.default.join(env.config.paths.cache, "solc-input.json"))
                    .toString();
            }
            catch (e) { }
            if (solcInput) {
                solcInputHash = solidity_1.keccak256(["string"], [solcInput]);
            }
        }
    }
    async function setupGasPrice(overrides) {
        if (!overrides.gasPrice) {
            overrides.gasPrice = await getGasPrice();
        }
    }
    async function overrideGasLimit(overrides, options, estimate) {
        const estimatedGasLimit = options.estimatedGasLimit
            ? bignumber_1.BigNumber.from(options.estimatedGasLimit).toNumber()
            : undefined;
        const estimateGasExtra = options.estimateGasExtra
            ? bignumber_1.BigNumber.from(options.estimateGasExtra).toNumber()
            : undefined;
        if (!overrides.gasLimit) {
            overrides.gasLimit = estimatedGasLimit;
            overrides.gasLimit = (await estimate(overrides)).toNumber();
            if (estimateGasExtra) {
                overrides.gasLimit = overrides.gasLimit + estimateGasExtra;
                if (estimatedGasLimit) {
                    overrides.gasLimit = Math.min(overrides.gasLimit, estimatedGasLimit);
                }
            }
        }
    }
    function getCreate2Address(create2DeployerAddress, salt, bytecode) {
        return address_1.getAddress("0x" +
            solidity_1.keccak256(["bytes"], [
                `0xff${create2DeployerAddress.slice(2)}${salt.slice(2)}${solidity_1.keccak256(["bytes"], [bytecode]).slice(2)}`
            ]).slice(-40));
    }
    async function ensureCreate2DeployerReady(options) {
        const { address: from, ethersSigner } = getFrom(options.from);
        if (!ethersSigner) {
            throw new Error("no signer for " + from);
        }
        const create2DeployerAddress = "0x4e59b44847b379578588920ca78fbf26c0b4956c";
        const code = await provider.getCode(create2DeployerAddress);
        if (code === "0x") {
            const senderAddress = "0x3fab184622dc19b6109349b94811493bf2a45362";
            if (options.log) {
                log(`sending eth to create2 contract deployer address (${senderAddress})...`);
            }
            // TODO gasPrice override
            await ethersSigner.sendTransaction({
                to: senderAddress,
                value: bignumber_1.BigNumber.from("10000000000000000").toHexString()
            });
            // await provider.send("eth_sendTransaction", [{
            //   from
            // }]);
            if (options.log) {
                log(`deploying create2 deployer contract (at ${create2DeployerAddress}) using deterministic deployment (https://github.com/Arachnid/deterministic-deployment-proxy)...`);
            }
            await provider.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
        }
        return create2DeployerAddress;
    }
    async function getArtifactFromOptions(name, options) {
        let artifact;
        let contractName;
        if (options.contract) {
            if (typeof options.contract === "string") {
                contractName = options.contract;
                artifact = await getArtifact(options.contract);
            }
            else {
                artifact = options.contract;
            }
        }
        else {
            contractName = name;
            artifact = await getArtifact(name);
        }
        return { artifact, contractName };
    }
    async function getArtifactInfo(name, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const artifactInfo = await getArtifactFromOptions(name, options);
        const { artifact } = artifactInfo;
        const { contractName } = artifactInfo;
        const abi = artifact.abi;
        const byteCode = linkLibraries(artifact, options.libraries);
        let contractSolcOutput;
        if (!contractName) {
            if (typeof options.contract === "object") {
                contractSolcOutput = {
                    metadata: (_a = options.contract) === null || _a === void 0 ? void 0 : _a.metadata,
                    methodIdentifiers: (_b = options.contract) === null || _b === void 0 ? void 0 : _b.methodIdentifiers,
                    storageLayout: (_c = options.contract) === null || _c === void 0 ? void 0 : _c.storageLayout,
                    userdoc: (_d = options.contract) === null || _d === void 0 ? void 0 : _d.userdoc,
                    devdoc: (_e = options.contract) === null || _e === void 0 ? void 0 : _e.devdoc,
                    evm: {
                        gasEstimates: (_f = options.contract) === null || _f === void 0 ? void 0 : _f.gasEstimates
                    }
                };
            }
            if (!contractSolcOutput || !contractSolcOutput.metadata) {
                log(`no metadata associated with contract deployed as ${name}, the contract object should include a metadata field`);
            }
        }
        else {
            // TODO wait for buidler v2 // then we can hard fails on missing metadata
            // if (artifact.metadata) {
            //   contractSolcOutput = {
            //     metadata: artifact.metadata,
            //     methodIdentifiers: artifact.methodIdentifiers,
            //     storageLayout: artifact.storageLayout,
            //     userdoc: artifact.userdoc,
            //     devdoc: artifact.devdoc,
            //     evm: {
            //       gasEstimates: artifact.gasEstimates
            //     }
            //   };
            // } else
            if (solcOutput) {
                for (const fileEntry of Object.entries(solcOutput.contracts)) {
                    for (const contractEntry of Object.entries(fileEntry[1])) {
                        if (contractEntry[0] === contractName) {
                            if (artifact.bytecode ===
                                "0x" + ((_h = (_g = contractEntry[1].evm) === null || _g === void 0 ? void 0 : _g.bytecode) === null || _h === void 0 ? void 0 : _h.object)) {
                                contractSolcOutput = contractEntry[1];
                            }
                        }
                    }
                }
            }
            else {
                log(`solc-output not found, it is not possible to get the metadata for ${name}. Check if the contract code exists (or if the artifacts belong to older contracts)`);
            }
        }
        return { abi, contractSolcOutput, byteCode, artifact };
    }
    async function _deploy(name, options) {
        var _a;
        const args = options.args ? [...options.args] : [];
        await init();
        const { address: from, ethersSigner } = getFrom(options.from);
        if (!ethersSigner) {
            throw new Error("no signer for " + from);
        }
        const { abi, contractSolcOutput, byteCode, artifact } = await getArtifactInfo(name, options);
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice,
            value: options.value,
            nonce: options.nonce
        };
        const factory = new contracts_1.ContractFactory(abi, byteCode, ethersSigner);
        const numArguments = factory.interface.deploy.inputs.length;
        if (args.length !== numArguments) {
            throw new Error(`expected ${numArguments} constructor arguments, got ${args.length}`);
        }
        const unsignedTx = factory.getDeployTransaction(...args, overrides);
        let create2Address;
        if (options.deterministicDeployment) {
            if (typeof unsignedTx.data === "string") {
                const create2DeployerAddress = await ensureCreate2DeployerReady(options);
                const create2Salt = typeof options.deterministicDeployment === "string"
                    ? bytes_1.hexlify(bytes_1.zeroPad(options.deterministicDeployment, 32))
                    : "0x0000000000000000000000000000000000000000000000000000000000000000";
                create2Address = getCreate2Address(create2DeployerAddress, create2Salt, unsignedTx.data);
                unsignedTx.to = create2DeployerAddress;
                unsignedTx.data = create2Salt + unsignedTx.data.slice(2);
            }
            else {
                throw new Error("unsigned tx data as bytes not supported");
            }
        }
        await overrideGasLimit(unsignedTx, options, newOverrides => ethersSigner.estimateGas(newOverrides));
        await setupGasPrice(unsignedTx);
        let tx = await ethersSigner.sendTransaction(unsignedTx);
        // await overrideGasLimit(overrides, options, newOverrides =>
        //   ethersSigner.estimateGas(newOverrides)
        // );
        // await setupGasPrice(overrides);
        // console.log({ args, overrides });
        // const ethersContract = await factory.deploy(...args, overrides);
        // let tx = ethersContract.deployTransaction;
        if (options.dev_forceMine) {
            try {
                await provider.send("evm_mine", []);
            }
            catch (e) { }
        }
        // const extendedAtifact = artifact as any; // TODO future version of buidler will hopefully have that info
        const preDeployment = {
            abi,
            args,
            linkedData: options.linkedData,
            solcInputHash,
            solcInput,
            metadata: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.metadata,
            bytecode: artifact.bytecode,
            deployedBytecode: artifact.deployedBytecode,
            libraries: options.libraries,
            userdoc: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.userdoc,
            devdoc: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.devdoc,
            methodIdentifiers: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.methodIdentifiers,
            storageLayout: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.storageLayout,
            gasEstimates: (_a = contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.evm) === null || _a === void 0 ? void 0 : _a.gasEstimates
        };
        tx = await onPendingTx(tx, name, preDeployment);
        const receipt = await tx.wait();
        const address = options.deterministicDeployment && create2Address
            ? create2Address
            : receipt.contractAddress;
        const deployment = Object.assign(Object.assign({}, preDeployment), { address,
            receipt, transactionHash: receipt.transactionHash });
        await env.deployments.save(name, deployment);
        return Object.assign(Object.assign({}, deployment), { address, newlyDeployed: true });
    }
    async function deterministic(name, options) {
        // TODO refactor to share that code:
        const args = options.args ? [...options.args] : [];
        await init();
        const { address: from, ethersSigner } = getFrom(options.from);
        if (!ethersSigner) {
            throw new Error("no signer for " + from);
        }
        const artifactInfo = await getArtifactFromOptions(name, options);
        const { artifact } = artifactInfo;
        const abi = artifact.abi;
        const byteCode = linkLibraries(artifact, options.libraries);
        const factory = new contracts_1.ContractFactory(abi, byteCode, ethersSigner);
        const numArguments = factory.interface.deploy.inputs.length;
        if (args.length !== numArguments) {
            throw new Error(`expected ${numArguments} constructor arguments, got ${args.length}`);
        }
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice,
            value: options.value,
            nonce: options.nonce
        };
        const unsignedTx = factory.getDeployTransaction(...args, overrides);
        if (typeof unsignedTx.data !== "string") {
            throw new Error("unsigned tx data as bytes not supported");
        }
        else {
            return {
                address: getCreate2Address("0x4e59b44847b379578588920ca78fbf26c0b4956c", options.salt
                    ? bytes_1.hexlify(bytes_1.zeroPad(options.salt, 32))
                    : "0x0000000000000000000000000000000000000000000000000000000000000000", unsignedTx.data),
                deploy: () => deploy(name, Object.assign(Object.assign({}, options), { deterministicDeployment: options.salt || true }))
            };
        }
    }
    function getDeployment(name) {
        return env.deployments.get(name);
    }
    function getDeploymentOrNUll(name) {
        return env.deployments.getOrNull(name);
    }
    async function fetchIfDifferent(name, options) {
        const argArray = options.args ? [...options.args] : [];
        await init();
        if (options.deterministicDeployment) {
            // TODO remove duplication:
            const { address: from, ethersSigner } = getFrom(options.from);
            if (!ethersSigner) {
                throw new Error("no signer for " + from);
            }
            const artifactInfo = await getArtifactFromOptions(name, options);
            const { artifact } = artifactInfo;
            const { contractName } = artifactInfo;
            const abi = artifact.abi;
            const byteCode = linkLibraries(artifact, options.libraries);
            const factory = new contracts_1.ContractFactory(abi, byteCode, ethersSigner);
            const numArguments = factory.interface.deploy.inputs.length;
            if (argArray.length !== numArguments) {
                throw new Error(`expected ${numArguments} constructor arguments, got ${argArray.length}`);
            }
            const overrides = {
                gasLimit: options.gasLimit,
                gasPrice: options.gasPrice,
                value: options.value,
                nonce: options.nonce
            };
            const unsignedTx = factory.getDeployTransaction(...argArray, overrides);
            if (typeof unsignedTx.data === "string") {
                const create2Salt = typeof options.deterministicDeployment === "string"
                    ? bytes_1.hexlify(bytes_1.zeroPad(options.deterministicDeployment, 32))
                    : "0x0000000000000000000000000000000000000000000000000000000000000000";
                const create2DeployerAddress = "0x4e59b44847b379578588920ca78fbf26c0b4956c";
                const create2Address = getCreate2Address(create2DeployerAddress, create2Salt, unsignedTx.data);
                const code = await provider.getCode(create2Address);
                if (code === "0x") {
                    return { differences: true, address: undefined };
                }
                else {
                    return { differences: false, address: create2Address };
                }
            }
            else {
                throw new Error("unsigned tx data as bytes not supported");
            }
        }
        const fieldsToCompareArray = typeof options.fieldsToCompare === "string"
            ? [options.fieldsToCompare]
            : options.fieldsToCompare || [];
        const deployment = await env.deployments.getOrNull(name);
        if (deployment) {
            if (options.skipIfAlreadyDeployed) {
                return { differences: false, address: undefined }; // TODO check receipt, see below
            }
            // TODO transactionReceipt + check for status
            let transaction;
            if (deployment.receipt) {
                transaction = await provider.getTransaction(deployment.receipt.transactionHash);
            }
            else if (deployment.transactionHash) {
                transaction = await provider.getTransaction(deployment.transactionHash);
            }
            if (transaction) {
                const { artifact } = await getArtifactFromOptions(name, options);
                const abi = artifact.abi;
                const byteCode = linkLibraries(artifact, options.libraries);
                const factory = new contracts_1.ContractFactory(abi, byteCode, provider.getSigner(options.from));
                const compareOnData = fieldsToCompareArray.indexOf("data") !== -1;
                let data;
                if (compareOnData) {
                    const deployStruct = factory.getDeployTransaction(...argArray);
                    data = deployStruct.data;
                }
                const newTransaction = {
                    data: compareOnData ? data : undefined,
                    gasLimit: options.gasLimit,
                    gasPrice: options.gasPrice,
                    value: options.value,
                    from: options.from
                };
                transaction.data = transaction.data;
                for (const field of fieldsToCompareArray) {
                    if (typeof newTransaction[field] === "undefined") {
                        throw new Error("field " +
                            field +
                            " not specified in new transaction, cant compare");
                    }
                    if (transaction[field] !== newTransaction[field]) {
                        return { differences: true, address: deployment.address };
                    }
                }
                return { differences: false, address: deployment.address };
            }
        }
        return { differences: true, address: undefined };
    }
    async function _deployOne(name, options) {
        var _a, _b;
        const argsArray = options.args ? [...options.args] : [];
        options = Object.assign(Object.assign({}, options), { args: argsArray });
        if (options.fieldsToCompare === undefined) {
            options.fieldsToCompare = ["data"];
        }
        let result;
        if (options.fieldsToCompare) {
            const diffResult = await fetchIfDifferent(name, options);
            if (diffResult.differences) {
                result = await _deploy(name, options);
            }
            else {
                const deployment = await getDeploymentOrNUll(name);
                if (deployment) {
                    result = deployment;
                }
                else {
                    if (!diffResult.address) {
                        throw new Error("no differences found but no address, this should be impossible");
                    }
                    const { abi, contractSolcOutput, artifact } = await getArtifactInfo(name, options);
                    // receipt missing
                    const newDeployment = {
                        abi,
                        address: diffResult.address,
                        linkedData: options.linkedData,
                        solcInputHash,
                        solcInput,
                        metadata: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.metadata,
                        bytecode: artifact.bytecode,
                        deployedBytecode: artifact.deployedBytecode,
                        libraries: options.libraries,
                        userdoc: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.userdoc,
                        devdoc: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.devdoc,
                        methodIdentifiers: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.methodIdentifiers,
                        storageLayout: contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.storageLayout,
                        gasEstimates: (_a = contractSolcOutput === null || contractSolcOutput === void 0 ? void 0 : contractSolcOutput.evm) === null || _a === void 0 ? void 0 : _a.gasEstimates
                    };
                    await env.deployments.save(name, newDeployment);
                    result = Object.assign(Object.assign({}, newDeployment), { newlyDeployed: false });
                }
            }
        }
        else {
            result = await _deploy(name, options);
        }
        if (options.log) {
            if (result.newlyDeployed) {
                log(`"${name}" deployed at ${result.address} with ${(_b = result.receipt) === null || _b === void 0 ? void 0 : _b.gasUsed} gas`);
            }
            else {
                log(`reusing "${name}" at ${result.address}`);
            }
        }
        return result;
    }
    function _checkUpgradeIndex(oldDeployment, upgradeIndex) {
        if (typeof upgradeIndex === "undefined") {
            return;
        }
        if (upgradeIndex === 0) {
            if (oldDeployment) {
                return Object.assign(Object.assign({}, oldDeployment), { newlyDeployed: false });
            }
        }
        else if (upgradeIndex === 1) {
            if (!oldDeployment) {
                throw new Error("upgradeIndex === 1 : expects Deployments to already exists");
            }
            if (oldDeployment.history && oldDeployment.history.length > 0) {
                return Object.assign(Object.assign({}, oldDeployment), { newlyDeployed: false });
            }
        }
        else {
            if (!oldDeployment) {
                throw new Error(`upgradeIndex === ${upgradeIndex} : expects Deployments to already exists`);
            }
            if (!oldDeployment.history) {
                throw new Error(`upgradeIndex > 1 : expects Deployments history to exists`);
            }
            else if (oldDeployment.history.length > upgradeIndex - 1) {
                return Object.assign(Object.assign({}, oldDeployment), { newlyDeployed: false });
            }
            else if (oldDeployment.history.length < upgradeIndex - 1) {
                throw new Error(`upgradeIndex === ${upgradeIndex} : expects Deployments history length to be at least ${upgradeIndex -
                    1}`);
            }
        }
    }
    async function _deployViaEIP173Proxy(name, options) {
        const oldDeployment = await getDeploymentOrNUll(name);
        let updateMethod;
        let upgradeIndex;
        if (typeof options.proxy === "object") {
            upgradeIndex = options.proxy.upgradeIndex;
            updateMethod = options.proxy.methodName;
        }
        else if (typeof options.proxy === "string") {
            updateMethod = options.proxy;
        }
        const deployResult = _checkUpgradeIndex(oldDeployment, upgradeIndex);
        if (deployResult) {
            return deployResult;
        }
        const proxyName = name + "_Proxy";
        const { address: owner } = getProxyOwner(options);
        const argsArray = options.args ? [...options.args] : [];
        // --- Implementation Deployment ---
        const implementationName = name + "_Implementation";
        const implementationOptions = Object.assign({}, options);
        delete implementationOptions.proxy;
        if (!implementationOptions.contract) {
            implementationOptions.contract = name;
        }
        const { artifact } = await getArtifactFromOptions(implementationName, implementationOptions);
        // ensure no clash
        utils_1.mergeABIs(true, EIP173Proxy_json_1.default.abi, artifact.abi);
        const constructor = artifact.abi.find((fragment) => fragment.type === "constructor");
        if (!constructor || constructor.inputs.length !== argsArray.length) {
            delete implementationOptions.args;
            if (constructor && constructor.inputs.length > 0) {
                throw new Error(`Proxy based contract constructor can only have either zero argument or the exact same argument as the method used for postUpgrade actions ${updateMethod ? "(" + updateMethod + "}" : ""}.
Plus they are only used when the contract is meant to be used as standalone when development ends.
`);
            }
        }
        const implementation = await _deployOne(implementationName, implementationOptions);
        // --- --------------------------- ---
        if (implementation.newlyDeployed) {
            // console.log(`implementation deployed at ${implementation.address} for ${implementation.receipt.gasUsed}`);
            const implementationContract = new contracts_1.Contract(implementation.address, implementation.abi);
            let data = "0x";
            if (updateMethod) {
                if (!implementationContract[updateMethod]) {
                    throw new Error(`contract need to implement function ${updateMethod}`);
                }
                const txData = await implementationContract.populateTransaction[updateMethod](...argsArray);
                data = txData.data || "0x";
            }
            let proxy = await getDeploymentOrNUll(proxyName);
            if (!proxy) {
                const proxyOptions = Object.assign({}, options);
                delete proxyOptions.proxy;
                proxyOptions.contract = EIP173Proxy_json_1.default;
                proxyOptions.args = [implementation.address, data, owner];
                proxy = await _deployOne(proxyName, proxyOptions);
                // console.log(`proxy deployed at ${proxy.address} for ${proxy.receipt.gasUsed}`);
            }
            else {
                let currentOwner;
                try {
                    currentOwner = await read(proxyName, Object.assign({}, options), "owner");
                }
                catch (e) {
                    const ownerStorage = await provider.getStorageAt(
                    // fallback on old proxy // TODO test
                    proxy.address, "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103");
                    currentOwner = bignumber_1.BigNumber.from(ownerStorage).toHexString();
                }
                if (currentOwner.toLowerCase() !== owner.toLowerCase()) {
                    throw new Error("To change owner, you need to call `transferOwnership`");
                }
                const executeReceipt = await execute(proxyName, Object.assign({}, options), "changeImplementation", implementation.address, data);
                if (!executeReceipt) {
                    throw new Error("could not execute `changeImplementation`");
                }
            }
            const proxiedDeployment = Object.assign(Object.assign({}, implementation), { address: proxy.address, execute: updateMethod
                    ? {
                        methodName: updateMethod,
                        args: argsArray
                    }
                    : undefined });
            if (oldDeployment) {
                proxiedDeployment.history = proxiedDeployment.history
                    ? proxiedDeployment.history.concat([oldDeployment])
                    : [oldDeployment];
            }
            await env.deployments.save(name, proxiedDeployment);
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: true });
        }
        else {
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: false });
        }
    }
    function getProxyOwner(options) {
        let address = options.from; // admim default to msg.sender
        if (typeof options.proxy === "object") {
            address = options.proxy.owner || address;
        }
        return getFrom(address);
    }
    function getOptionalFrom(from) {
        return _getFrom(from, true);
    }
    function getFrom(from) {
        return _getFrom(from, false);
    }
    function _getFrom(from, optional) {
        let ethersSigner;
        if (!from) {
            if (optional) {
                return {};
            }
            throw new Error("no from specified");
        }
        if (from.length >= 64) {
            if (from.length === 64) {
                from = "0x" + from;
            }
            const wallet = new wallet_1.Wallet(from);
            from = wallet.address;
            ethersSigner = wallet;
        }
        else {
            if (availableAccounts[from.toLowerCase()]) {
                ethersSigner = provider.getSigner(from);
            }
        }
        return { address: from, ethersSigner };
    }
    async function findEvents(contract, event, blockHash) {
        // TODO type the return type
        const filter = contract.filters[event]();
        const events = await contract.queryFilter(filter, blockHash);
        return events;
    }
    function sigsFromABI(abi) {
        return abi
            .filter((fragment) => fragment.type === "function")
            .map((fragment) => abi_1.Interface.getSighash(abi_1.FunctionFragment.from(fragment)));
    }
    async function _deployViaDiamondProxy(name, options) {
        const oldDeployment = await getDeploymentOrNUll(name);
        let proxy;
        const deployResult = _checkUpgradeIndex(oldDeployment, options.upgradeIndex);
        if (deployResult) {
            return deployResult;
        }
        const proxyName = name + "_DiamondProxy";
        const { address: owner, ethersSigner: ownerSigner } = getProxyOwner(options);
        const facetSnapshot = [];
        const oldFacets = [];
        if (oldDeployment) {
            proxy = await getDeployment(proxyName);
            const diamondProxy = new contracts_1.Contract(proxy.address, proxy.abi, provider);
            const currentFacetCuts = await diamondProxy.facets();
            for (const currentFacetCut of currentFacetCuts) {
                oldFacets.push(currentFacetCut);
                // ensure DiamondLoupeFacet, OwnershipFacet and DiamondCutFacet are kept // TODO options to delete cut them out?
                if (findAll([
                    "0xcdffacc6",
                    "0x52ef6b2c",
                    "0xadfca15e",
                    "0x7a0ed627",
                    "0x01ffc9a7"
                ], currentFacetCut.functionSelectors) || // Loupe
                    currentFacetCut.functionSelectors[0] === "e712b4e1" || // DiamoncCut
                    findAll(["0xf2fde38b", "0x8da5cb5b"], currentFacetCut.functionSelectors) // ERC173
                ) {
                    facetSnapshot.push(currentFacetCut);
                }
            }
        }
        // console.log({ oldFacets: JSON.stringify(oldFacets, null, "  ") });
        let changesDetected = !oldDeployment;
        let abi = Diamond_json_1.default.abi.concat([]);
        const facetCuts = [];
        for (const facet of options.facets) {
            const artifact = await getArtifact(facet); // TODO getArtifactFromOptions( // allowing to pass bytecode / abi
            const constructor = artifact.abi.find((fragment) => fragment.type === "constructor");
            if (constructor) {
                throw new Error(`Facet must not have a constructor`);
            }
            abi = utils_1.mergeABIs(true, abi, artifact.abi);
            // TODO allow facet to be named so multiple version could coexist
            const implementation = await _deployOne(facet, {
                from: options.from,
                log: options.log,
                libraries: options.libraries
            });
            if (implementation.newlyDeployed) {
                // console.log(`facet ${facet} deployed at ${implementation.address}`);
                changesDetected = true;
                const facetCut = {
                    facetAddress: implementation.address,
                    functionSelectors: sigsFromABI(implementation.abi)
                };
                facetCuts.push(facetCut);
                facetSnapshot.push(facetCut);
            }
            else {
                const oldImpl = await getDeployment(facet);
                const facetCut = {
                    facetAddress: oldImpl.address,
                    functionSelectors: sigsFromABI(oldImpl.abi)
                };
                facetSnapshot.push(facetCut);
                if (!oldFacets.find(f => f.facetAddress.toLowerCase() === oldImpl.address.toLowerCase())) {
                    facetCuts.push(facetCut);
                }
            }
        }
        for (const oldFacet of oldFacets) {
            if (!facetSnapshot.find(f => f.facetAddress.toLowerCase() === oldFacet.facetAddress.toLowerCase())) {
                changesDetected = true;
                facetCuts.unshift({
                    facetAddress: "0x0000000000000000000000000000000000000000",
                    functionSelectors: oldFacet.functionSelectors
                });
            }
        }
        let data = "0x";
        if (options.execute) {
            const diamondContract = new contracts_1.Contract("0x0000000000000000000000000000000000000001", abi);
            const txData = await diamondContract.populateTransaction[options.execute.methodName](...options.execute.args);
            data = txData.data || "0x";
        }
        if (changesDetected) {
            if (!proxy) {
                // ensure a Diamantaire exists on the network :
                const diamantaireName = "Diamantaire";
                let diamantaireDeployment = await getDeploymentOrNUll(diamantaireName);
                diamantaireDeployment = await _deployOne(diamantaireName, {
                    contract: Diamantaire_json_1.default,
                    from: options.from,
                    deterministicDeployment: true
                });
                const diamantaireContract = new contracts_1.Contract(diamantaireDeployment.address, Diamantaire_json_1.default.abi, provider);
                // the diamantaire allow the execution of data at diamond construction time
                let salt = "0x0000000000000000000000000000000000000000000000000000000000000000";
                if (typeof options.deterministicSalt !== "undefined") {
                    if (typeof options.deterministicSalt === "string") {
                        if (options.deterministicSalt === salt) {
                            throw new Error(`deterministicSalt cannot be 0x000..., it needs to be a non-zero bytes32 salt. This is to ensure you are explicitly specyfying different addresses for multiple diamonds`);
                        }
                        else {
                            if (options.deterministicSalt.length !== 66) {
                                throw new Error(`deterministicSalt needs to be a string of 66 hexadecimal characters (including the 0x prefix)`);
                            }
                            salt = options.deterministicSalt;
                        }
                    }
                    else {
                        throw new Error(`deterministicSalt need to be a string, an non-zero bytes32 salt`);
                    }
                }
                const createReceipt = await execute(diamantaireName, options, "createDiamond", owner, facetCuts, data, salt);
                if (!createReceipt) {
                    throw new Error(`failed to get receipt from diamond creation`);
                }
                const events = [];
                if (createReceipt.logs) {
                    for (const l of createReceipt.logs) {
                        try {
                            events.push(diamantaireContract.interface.parseLog(l));
                        }
                        catch (e) { }
                    }
                }
                const diamondCreatedEvent = events.find(e => e.name === "DiamondCreated");
                if (!diamondCreatedEvent) {
                    throw new Error("DiamondCreated Not Emitted");
                }
                const proxyAddress = diamondCreatedEvent.args.diamond;
                if (options.log) {
                    log(`Diamond deployed at ${proxyAddress} via Diamantaire (${diamantaireDeployment.address}) cuts: ${facetCuts} with ${createReceipt.gasUsed} gas`);
                }
                if (salt !==
                    "0x0000000000000000000000000000000000000000000000000000000000000000") {
                    const expectedAddress = getCreate2Address(diamantaireContract.address, solidity_1.keccak256(["bytes32", "address"], [salt, owner]), Diamond_json_1.default.bytecode +
                        "000000000000000000000000" +
                        diamantaireContract.address.slice(2));
                    if (expectedAddress !== proxyAddress) {
                        throw new Error(`unexpected address ${proxyAddress} VS ${expectedAddress}`);
                    }
                }
                proxy = {
                    abi: Diamond_json_1.default.abi,
                    address: proxyAddress,
                    receipt: createReceipt,
                    transactionHash: createReceipt.transactionHash,
                    args: [owner],
                    bytecode: Diamond_json_1.default.bytecode,
                    deployedBytecode: Diamond_json_1.default.deployedBytecode,
                    metadata: Diamond_json_1.default.metadata
                    // TODO if more fiels are added, we need to add more
                };
                await env.deployments.save(proxyName, proxy);
                await env.deployments.save(name, {
                    address: proxy.address,
                    receipt: proxy.receipt,
                    transactionHash: proxy.transactionHash,
                    linkedData: options.linkedData,
                    facets: facetSnapshot,
                    diamondCut: facetCuts,
                    abi,
                    execute: options.execute
                    // metadata: diamondBase.metadata
                });
            }
            else {
                if (!oldDeployment) {
                    throw new Error(`Cannot find Deployment for ${name}`);
                }
                const currentOwner = await read(proxyName, "owner");
                if (currentOwner.toLowerCase() !== owner.toLowerCase()) {
                    throw new Error(`The Diamond owner is not ${owner}`);
                }
                const executeReceipt = await execute(name, options, "diamondCut", facetCuts, data === "0x"
                    ? "0x0000000000000000000000000000000000000000"
                    : proxy.address, data);
                if (!executeReceipt) {
                    throw new Error("failed to execute");
                }
                await env.deployments.save(name, {
                    receipt: executeReceipt,
                    transactionHash: executeReceipt.transactionHash,
                    history: oldDeployment.history
                        ? oldDeployment.history.concat(oldDeployment)
                        : [oldDeployment],
                    linkedData: options.linkedData,
                    address: proxy.address,
                    abi,
                    facets: facetSnapshot,
                    diamondCut: facetCuts,
                    execute: options.execute
                    // metadata: oldDeployment.metadata
                });
            }
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: true });
        }
        else {
            const deployment = await env.deployments.get(name);
            return Object.assign(Object.assign({}, deployment), { newlyDeployed: false });
        }
    }
    async function deploy(name, options) {
        await init();
        if (!options.proxy) {
            return _deployOne(name, options);
        }
        return _deployViaEIP173Proxy(name, options);
    }
    async function diamond(name, options) {
        await init();
        return _deployViaDiamondProxy(name, options);
    }
    async function rawTx(tx) {
        await init();
        const { address: from, ethersSigner } = getFrom(tx.from);
        if (!ethersSigner) {
            throw new errors_1.UnknownSignerError({
                from,
                to: tx.to,
                data: tx.data,
                value: tx.value
            });
        }
        else {
            const transactionData = {
                to: tx.to,
                gasLimit: tx.gasLimit,
                gasPrice: tx.gasPrice ? bignumber_1.BigNumber.from(tx.gasPrice) : undefined,
                value: tx.value ? bignumber_1.BigNumber.from(tx.value) : undefined,
                nonce: tx.nonce,
                data: tx.data
            };
            let pendingTx = await ethersSigner.sendTransaction(transactionData);
            pendingTx = await onPendingTx(pendingTx);
            if (tx.dev_forceMine) {
                try {
                    await provider.send("evm_mine", []);
                }
                catch (e) { }
            }
            return pendingTx.wait();
        }
    }
    async function catchUnknownSigner(action) {
        try {
            if (action instanceof Promise) {
                await action;
            }
            else {
                await action();
            }
        }
        catch (e) {
            if (e instanceof errors_1.UnknownSignerError) {
                const { from, to, data, value, contract } = e.data;
                console.error("no signer for " + from);
                if (contract) {
                    console.log(`Please execute the following on ${contract.name}`);
                    console.log(`
from: ${from}
to: ${to}
value: ${value ? (typeof value === "string" ? value : value.toString()) : "0"}
data: ${data}
`);
                    console.log("if you have an interface use the following");
                    console.log(`
from: ${from}
to: ${to} (${contract.name})
value: ${value}
method: ${contract.method}
args: [${contract.args.join(",")}]
`);
                }
                else {
                    console.log(`Please execute the following`);
                    console.log(`
from: ${from}
to: ${to}
value: ${value ? (typeof value === "string" ? value : value.toString()) : "0"}
data: ${data}
`);
                }
            }
            else {
                throw e;
            }
        }
    }
    async function execute(name, options, methodName, ...args) {
        await init();
        const { address: from, ethersSigner } = getFrom(options.from);
        let tx;
        const deployment = await env.deployments.get(name);
        const abi = deployment.abi;
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice ? bignumber_1.BigNumber.from(options.gasPrice) : undefined,
            value: options.value ? bignumber_1.BigNumber.from(options.value) : undefined,
            nonce: options.nonce
        };
        const ethersContract = new contracts_1.Contract(deployment.address, abi, ethersSigner || provider);
        if (!ethersContract.functions[methodName]) {
            throw new Error(`No method named "${methodName}" on contract deployed as "${name}"`);
        }
        const numArguments = ethersContract.interface.getFunction(methodName).inputs
            .length;
        if (args.length !== numArguments) {
            throw new Error(`expected ${numArguments} arguments for method "${methodName}", got ${args.length}`);
        }
        if (!ethersSigner) {
            const ethersArgs = args ? args.concat([overrides]) : [overrides];
            const { data } = await ethersContract.populateTransaction[methodName](...ethersArgs);
            throw new errors_1.UnknownSignerError({
                from,
                to: deployment.address,
                data,
                value: options.value,
                contract: {
                    name,
                    method: methodName,
                    args
                }
            });
        }
        else {
            await overrideGasLimit(overrides, options, newOverrides => {
                const ethersArgsWithGasLimit = args
                    ? args.concat([newOverrides])
                    : [newOverrides];
                return ethersContract.estimateGas[methodName](...ethersArgsWithGasLimit);
            });
            await setupGasPrice(overrides);
            const ethersArgs = args ? args.concat([overrides]) : [overrides];
            tx = await ethersContract.functions[methodName](...ethersArgs);
        }
        tx = await onPendingTx(tx);
        if (options.log) {
            print(`executing ${name}.${methodName}... `);
        }
        if (options.dev_forceMine) {
            try {
                await provider.send("evm_mine", []);
            }
            catch (e) { }
        }
        const receipt = await tx.wait();
        if (options.log) {
            print(`: performed with ${receipt.gasUsed} gas\n`);
        }
        return receipt;
    }
    // TODO ?
    // async function rawCall(to: string, data: string) {
    //   // TODO call it eth_call?
    //   await init();
    //   return provider.send("eth_call", [
    //     {
    //       to,
    //       data
    //     },
    //     "latest"
    //   ]); // TODO overrides
    // }
    async function read(name, options, methodName, ...args) {
        await init();
        if (typeof options === "string") {
            if (typeof methodName !== "undefined") {
                args.unshift(methodName);
            }
            methodName = options;
            options = {};
        }
        if (typeof args === "undefined") {
            args = [];
        }
        let caller = provider;
        const { ethersSigner } = getOptionalFrom(options.from);
        if (ethersSigner) {
            caller = ethersSigner;
        }
        const deployment = await env.deployments.get(name);
        if (!deployment) {
            throw new Error(`no contract named "${name}"`);
        }
        const abi = deployment.abi;
        const overrides = {
            gasLimit: options.gasLimit,
            gasPrice: options.gasPrice ? bignumber_1.BigNumber.from(options.gasPrice) : undefined,
            value: options.value ? bignumber_1.BigNumber.from(options.value) : undefined,
            nonce: options.nonce
        };
        const ethersContract = new contracts_1.Contract(deployment.address, abi, caller);
        // populate function
        // if (options.outputTx) {
        //   const method = ethersContract.populateTransaction[methodName];
        //   if (!method) {
        //     throw new Error(
        //       `no method named "${methodName}" on contract "${name}"`
        //     );
        //   }
        //   if (args.length > 0) {
        //     return method(...args, overrides);
        //   } else {
        //     return method(overrides);
        //   }
        // }
        const method = ethersContract.callStatic[methodName];
        if (!method) {
            throw new Error(`no method named "${methodName}" on contract "${name}"`);
        }
        if (args.length > 0) {
            return method(...args, overrides);
        }
        else {
            return method(overrides);
        }
    }
    const extension = Object.assign(Object.assign({}, partialExtension), { fetchIfDifferent,
        deploy, diamond: {
            deploy: diamond
        }, catchUnknownSigner,
        execute,
        rawTx,
        read,
        deterministic });
    // ////////// Backward compatible for transition: //////////////////
    extension.call = (options, name, methodName, ...args) => {
        if (typeof options === "string") {
            args = args || [];
            if (methodName !== undefined) {
                args.unshift(methodName);
            }
            methodName = name;
            name = options;
            options = {};
        }
        return read(name, options, methodName, ...args);
    };
    extension.sendTxAndWait = (options, name, methodName, ...args) => {
        return execute(name, options, methodName, ...args);
    };
    extension.deployIfDifferent = (fieldsToCompare, name, options, contractName, ...args) => {
        options.fieldsToCompare = fieldsToCompare;
        options.contract = contractName;
        options.args = args;
        return deploy(name, options);
    };
    // ////////////////////////////////////////////////////////////////////
    return extension;
}
exports.addHelpers = addHelpers;
function pause(duration) {
    return new Promise(res => setTimeout(res, duration * 1000));
}
async function waitForTx(ethereum, txHash, isContract) {
    let receipt;
    while (true) {
        try {
            receipt = await ethereum.send("eth_getTransactionReceipt", [txHash]);
        }
        catch (e) { }
        if (receipt && receipt.blockNumber) {
            if (isContract) {
                if (!receipt.contractAddress) {
                    throw new Error("contract not deployed");
                }
                else {
                    return receipt;
                }
            }
            else {
                return receipt;
            }
        }
        await pause(2);
    }
}
exports.waitForTx = waitForTx;
//# sourceMappingURL=helpers.js.map