"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const utils_1 = require("./calledOnContract/utils");
const account_1 = require("./misc/account");
function supportChangeBalances(Assertion) {
    Assertion.addMethod('changeBalances', function (signers, balanceChanges) {
        const subject = this._obj;
        const derivedPromise = Promise.all([
            getBalanceChanges(subject, signers),
            getAddresses(signers)
        ]).then(([actualChanges, signerAddresses]) => {
            this.assert(actualChanges.every((change, ind) => change.eq(ethers_1.BigNumber.from(balanceChanges[ind]))), `Expected ${signerAddresses} to change balance by ${balanceChanges} wei, ` +
                `but it has changed by ${actualChanges} wei`, `Expected ${signerAddresses} to not change balance by ${balanceChanges} wei,`, balanceChanges.map((balanceChange) => balanceChange.toString()), actualChanges.map((actualChange) => actualChange.toString()));
        });
        this.then = derivedPromise.then.bind(derivedPromise);
        this.catch = derivedPromise.catch.bind(derivedPromise);
        this.promise = derivedPromise;
        return this;
    });
}
exports.supportChangeBalances = supportChangeBalances;
async function getBalanceChanges(transaction, accounts) {
    if (typeof transaction === 'function') {
        return getBalancesChangeForTransactionCall(transaction, accounts);
    }
    else {
        return getBalancesChangeForTransactionResponse(transaction, accounts);
    }
}
function getAddresses(accounts) {
    return Promise.all(accounts.map((account) => account_1.getAddressOf(account)));
}
async function getBalances(accounts, blockNumber) {
    return Promise.all(accounts.map((account) => {
        utils_1.ensure(account.provider !== undefined, TypeError, 'Provider not found');
        if (blockNumber) {
            return account.provider.getBalance(account_1.getAddressOf(account), blockNumber);
        }
        else {
            return account.provider.getBalance(account_1.getAddressOf(account));
        }
    }));
}
async function getBalancesChangeForTransactionCall(transactionCall, accounts) {
    const balancesBefore = await getBalances(accounts);
    await transactionCall();
    const balancesAfter = await getBalances(accounts);
    return balancesAfter.map((balance, ind) => balance.sub(balancesBefore[ind]));
}
async function getBalancesChangeForTransactionResponse(transactionResponse, accounts) {
    const transactionBlockNumber = (await transactionResponse.wait()).blockNumber;
    const balancesAfter = await getBalances(accounts, transactionBlockNumber);
    const balancesBefore = await getBalances(accounts, transactionBlockNumber - 1);
    return balancesAfter.map((balance, ind) => balance.sub(balancesBefore[ind]));
}
